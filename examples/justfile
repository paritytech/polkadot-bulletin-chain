# Polkadot Bulletin Chain - Just Commands
# 
# See README.md for usage instructions.

# PID file locations
PID_DIR := "/tmp/bulletin-pids"

# Default recipe - run the complete PAPI workflow test
default: (run-authorize-and-store "smoldot" "bulletin-polkadot-runtime")

# Build the bulletin chain node in release mode
# Parameters:
#   runtime - Runtime name (e.g., "bulletin-polkadot"), taken from ../scripts/runtimes-matrix.json
build runtime="bulletin-polkadot-runtime":
    cargo build --release -p {{ runtime }}

# Install JavaScript dependencies
npm-install:
    npm install

# Helper function to get IPFS command (internal use)
_ipfs-cmd:
    #!/usr/bin/env bash
    if [ -f "../kubo/ipfs" ]; then
        echo "../kubo/ipfs"
    elif command -v ipfs &> /dev/null; then
        echo "ipfs"
    else
        echo "âŒ Error: IPFS not found." >&2
        exit 1
    fi

# Helper function to map runtime package name to zombienet config filename (internal use)
_zombienet-config-name runtime:
    #!/usr/bin/env bash
    case "{{ runtime }}" in
        "bulletin-polkadot-runtime")
            echo "bulletin-polkadot-local.toml"
            ;;
        "bulletin-westend-runtime")
            echo "bulletin-westend-local.toml"
            ;;
        "polkadot-bulletin-chain-runtime")
            echo "bulletin-polkadot.toml"
            ;;
        *)
            echo "âŒ Error: Unknown runtime '{{ runtime }}'" >&2
            exit 1
            ;;
    esac

# Start start solo chain with zombienet in background
# Parameters:
#   runtime - Runtime name (e.g., "bulletin-polkadot"), taken from ../scripts/runtimes-matrix.json
bulletin-solo-zombienet-start runtime="bulletin-polkadot":
    #!/usr/bin/env bash
    set -e
    
    mkdir -p {{ PID_DIR }}
    
    echo "âš¡ Starting Bulletin chain with zombienet (runtime: {{ runtime }})..."
    
    # Find zombienet binary (use env var if set, otherwise search)
    if [ -n "$ZOMBIENET_BINARY" ]; then
        ZOMBIENET_BIN="$ZOMBIENET_BINARY"
    else
        ZOMBIENET_BIN=$(ls ../zombienet-*-* 2>/dev/null | head -n 1)
    fi
    
    if [ -z "$ZOMBIENET_BIN" ] || [ ! -f "$ZOMBIENET_BIN" ]; then
        echo "âŒ Error: Zombienet binary not found"
        echo "   Tried: $ZOMBIENET_BIN"
        echo "   Set ZOMBIENET_BINARY environment variable or ensure zombienet-* exists in parent directory"
        exit 1
    fi
    
    echo "   Using zombienet: $ZOMBIENET_BIN"
    
    # Get absolute paths for bulletin binary and config
    BULLETIN_BINARY=$(cd .. && pwd)/target/release/{{ runtime }}
    ZOMBIENET_TOML=$(just _zombienet-config-name {{ runtime }})
    ZOMBIENET_CONFIG=$(cd .. && pwd)/zombienet/$ZOMBIENET_TOML
    
    echo "   Using config: $ZOMBIENET_CONFIG"
    
    POLKADOT_BULLETIN_BINARY_PATH=$BULLETIN_BINARY $ZOMBIENET_BIN -p native spawn $ZOMBIENET_CONFIG > /tmp/zombienet.log 2>&1 &
    ZOMBIENET_PID=$!
    echo $ZOMBIENET_PID > {{ PID_DIR }}/zombienet.pid
    echo "   Zombienet PID: $ZOMBIENET_PID"
    echo "   Log: /tmp/zombienet.log"
    echo "   Waiting for chain to start (15 seconds)..."
    sleep 15

# Check if Docker is available and running
_check-docker:
    #!/usr/bin/env bash
    if ! command -v docker &> /dev/null; then
        echo "âŒ Error: Docker is not installed."
        echo "   Please install Docker Desktop from: https://www.docker.com/products/docker-desktop"
        exit 1
    fi
    
    if ! docker ps &> /dev/null; then
        echo "âŒ Error: Docker is not running."
        echo "   Please start Docker Desktop and try again."
        echo "   On macOS: Open Docker Desktop from Applications"
        exit 1
    fi

# Start IPFS Docker container
ipfs-start: _check-docker
    #!/usr/bin/env bash
    set -e
    mkdir -p {{ PID_DIR }}
    
    echo "ğŸ³ Starting IPFS Docker container..."
    
    # Pull latest kubo image if not present
    docker pull ipfs/kubo:latest
    
    # Determine network mode based on OS
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS - use port mapping
        NETWORK_ARGS="-p 4001:4001 -p 8080:8080 -p 5001:5001"
    else
        # Linux (including CI) - use host networking for direct access
        NETWORK_ARGS="--network host -p 4001:4001 -p 8080:8080 -p 5001:5001"
    fi
    
    # Start Docker container
    docker run -d --name ipfs-node -v ipfs-data:/data/ipfs $NETWORK_ARGS ipfs/kubo:latest
    echo "   Container: ipfs-node"
    echo "   Waiting for container to start..."
    sleep 5
    
    # Store container name in PID directory for cleanup
    echo "ipfs-node" > {{ PID_DIR }}/ipfs-docker.container

# Connect to IPFS nodes using Docker
ipfs-connect:
    #!/usr/bin/env bash
    set -e
    
    echo "ğŸ”— Connecting IPFS nodes (Docker)..."
    
    # Detect the correct host and protocol for Docker
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS - use dns4/host.docker.internal
        PROTOCOL="dns4"
        DOCKER_HOST="host.docker.internal"
    else
        # Linux (with host networking) - use ip4/127.0.0.1
        PROTOCOL="ip4"
        DOCKER_HOST="127.0.0.1"
    fi
    
    echo "   Using Docker host: /$PROTOCOL/$DOCKER_HOST"
    docker exec ipfs-node ipfs swarm connect /$PROTOCOL/$DOCKER_HOST/tcp/10001/ws/p2p/12D3KooWQCkBm1BYtkHpocxCwMgR8yjitEeHGx8spzcDLGt2gkBm || true
    docker exec ipfs-node ipfs swarm connect /$PROTOCOL/$DOCKER_HOST/tcp/12347/ws/p2p/12D3KooWRkZhiRhsqmrQ28rt73K7V3aCBpqKrLGSXmZ99PTcTZby || true

# Shutdown IPFS Docker container
ipfs-shutdown:
    #!/usr/bin/env bash
    
    echo "ğŸ›‘ Shutting down IPFS Docker container..."
    docker stop ipfs-node 2>/dev/null || echo "   âš  Container not running or already stopped"
    docker rm ipfs-node 2>/dev/null || echo "   âš  Container not found or already removed"
    
    # Clean up container file if it exists
    [ -f "{{ PID_DIR }}/ipfs-docker.container" ] && rm "{{ PID_DIR }}/ipfs-docker.container" && echo "   âœ“ Cleaned up container file" || true

# Start IPFS reconnect script in background (Docker mode)
ipfs-reconnect-start:
    #!/usr/bin/env bash
    set -e
    
    mkdir -p {{ PID_DIR }}
    
    echo "ğŸ”„ Starting IPFS reconnect script (Docker mode)..."
    ./scripts/ipfs-reconnect-solo.sh docker > /tmp/ipfs-reconnect-docker.log 2>&1 &
    RECONNECT_PID=$!
    echo $RECONNECT_PID > {{ PID_DIR }}/ipfs-reconnect-docker.pid
    echo "   Reconnect PID: $RECONNECT_PID"
    echo "   Log: /tmp/ipfs-reconnect-docker.log"
    sleep 2

# Generate PAPI descriptors
papi-generate:
    #!/usr/bin/env bash
    set -e

    echo "ğŸ”§ Generating PAPI descriptors..."
    npm run papi:generate

# Setup all services using Docker for IPFS
# Parameters:
#   runtime - Runtime to build and run (e.g., "bulletin-polkadot-runtime", "bulletin-westend-runtime", "polkadot-bulletin-chain-runtime")
setup-services runtime="bulletin-polkadot":
    #!/usr/bin/env bash
    set -e
    
    echo "ğŸ”§ Tearing down Docker services if they are running..."
    just ipfs-shutdown
    
    echo "ğŸ³ Setting up services with Docker IPFS (runtime: {{ runtime }})..."
    
    # Start services with Docker
    just ipfs-start
    just bulletin-solo-zombienet-start "{{ runtime }}"
    
    # Wait a bit longer and verify zombienet is running
    echo "ğŸ” Verifying zombienet is ready..."
    sleep 10
    echo "   Zombienet process check:"
    ps aux | grep zombienet | grep -v grep || echo "   âš  No zombienet process found"
    echo "   Checking zombienet log:"
    tail -20 /tmp/zombienet.log || echo "   âš  Could not read zombienet log"
    
    just ipfs-connect
    just ipfs-reconnect-start
    just papi-generate
    
    echo "âœ… Services setup complete (Docker mode)"

# Stop all Docker services
teardown-services:
    #!/usr/bin/env bash
    
    echo "ğŸ§¹ Stopping all Docker services..."
    
    # Stop reconnect script
    if [ -d {{ PID_DIR }} ]; then
        for pidfile in {{ PID_DIR }}/*.pid; do
            if [ -f "$pidfile" ]; then
                PID=$(cat "$pidfile")
                SERVICE=$(basename "$pidfile" .pid)
                if kill $PID 2>/dev/null; then
                    echo "   âœ“ Stopped $SERVICE (PID: $PID)"
                else
                    echo "   âš  $SERVICE (PID: $PID) not running or already stopped"
                fi
                rm "$pidfile"
            fi
        done
    fi
    
    # Stop Docker container
    just ipfs-shutdown
    
    # Clean up PID directory
    if [ -d {{ PID_DIR }} ]; then
        rmdir {{ PID_DIR }} 2>/dev/null || true
    fi
    
    echo "âœ… Docker services stopped"

# Run authorize and store example with Docker IPFS
# Parameters:
#   mode - Connection mode: "ws" (WebSocket RPC node) or "smoldot" (light client)
#   runtime - Runtime name (e.g., "bulletin-polkadot", "bulletin-westend", "bulletin-rococo")
run-authorize-and-store mode="ws" runtime="bulletin-polkadot": (build runtime) npm-install
    #!/usr/bin/env bash
    set -e

    if [ "{{ mode }}" = "smoldot" ]; then
        echo "ğŸš€ Starting authorize and store workflow test (mode: smoldot, runtime: {{ runtime }})..."
        SCRIPT_NAME="authorize_and_store_papi_smoldot.js"
    elif [ "{{ mode }}" = "ws" ]; then
        echo "ğŸš€ Starting authorize and store workflow test (mode: ws, runtime: {{ runtime }})..."
        SCRIPT_NAME="authorize_and_store_papi.js"
    else
        echo "âŒ Error: Invalid mode '{{ mode }}'. Must be 'ws' or 'smoldot'"
        exit 1
    fi
    echo ""
    
    just setup-services "{{ runtime }}"
    node $SCRIPT_NAME
    EXAMPLE_EXIT=$?
    
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    if [ $EXAMPLE_EXIT -eq 0 ]; then
        echo "âœ… Example completed successfully!"
    else
        echo "âŒ Example failed with exit code $EXAMPLE_EXIT"
    fi
    
    just teardown-services    
    exit $EXAMPLE_EXIT

