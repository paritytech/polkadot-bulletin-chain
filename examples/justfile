# Polkadot Bulletin Chain - Just Commands
# 
# See README.md for usage instructions.

# Default recipe - run the complete PAPI workflow test
default: (run-authorize-and-store "bulletin-westend-runtime" "papi")

# Setup prerequisites for parachain runtime (polkadot and polkadot-omni-node binaries)
# This recipe clones polkadot-sdk, builds required binaries, and copies them to ~/local_bulletin_testing/bin
setup-parachain-prerequisites:
    #!/usr/bin/env bash
    set -e
    if [ -n "$SKIP_PARACHAIN_SETUP" ]; then
        echo "â­ï¸  Skipping parachain prerequisites (SKIP_PARACHAIN_SETUP set)"
    else
        ROOT_DIR="{{ justfile_directory() }}/.."
        cd "$ROOT_DIR"
        ./scripts/setup_parachain_prerequisites.sh
        cd -
    fi

compute-test-dir:
    #!/usr/bin/env bash
    if [ -n "$TEST_DIR" ]; then
        echo "$TEST_DIR";
    else
        TEST_DIR="$(mktemp -d /tmp/bulletin-tests-run-XXXXX)/test";
        mkdir -p "$TEST_DIR";
        echo "$TEST_DIR";
    fi

# Install JavaScript dependencies
npm-install:
    cd typescript && npm install

# Helper function to get IPFS command (internal use)
_ipfs-cmd:
    #!/usr/bin/env bash
    if [ -f "../kubo/ipfs" ]; then
        echo "../kubo/ipfs"
    elif command -v ipfs &> /dev/null; then
        echo "ipfs"
    else
        echo "âŒ Error: IPFS not found." >&2
        exit 1
    fi

kill-pids test_dir:
    #!/usr/bin/env bash
    set -e

    # Kill any existing background processes using stored PIDs
    echo "ğŸ” Checking for existing background processes - PIDs stored in {{ test_dir }}..."
    for pidfile in {{ test_dir }}/*.pid; do
        if [ -f "$pidfile" ]; then
            PID=$(cat "$pidfile")
            SERVICE=$(basename "$pidfile" .pid)
            if kill -0 $PID 2>/dev/null; then
                echo "   Found existing $SERVICE process (PID: $PID), pidfile: $pidfile"
                # Kill the process and its children
                pkill -TERM -P $PID 2>/dev/null || true
                sleep 2
                pkill -9 -P $PID 2>/dev/null || true
                sleep 2
                kill -9 $PID 2>/dev/null || true
                echo "   âœ“ Cleaned up $SERVICE process"
            else
                echo "   Stale $SERVICE PID file: $pidfile found (process not running)"
            fi
            rm "$pidfile"
        fi
    done

# Start solo chain or parachain with zombienet in background
# Parameters:
#   runtime - Runtime name (e.g., "bulletin-polkadot-runtime"), taken from ../scripts/runtimes-matrix.json
bulletin-solo-zombienet-start test_dir runtime="bulletin-polkadot-runtime":
    #!/usr/bin/env bash
    set -e

    # Find zombienet binary (use env var if set, otherwise search)
    if [ -n "$ZOMBIENET_BINARY" ]; then
        ZOMBIENET_BIN="$ZOMBIENET_BINARY"
    else
        ZOMBIENET_BIN=$(ls ../zombienet-*-* 2>/dev/null | head -n 1)
    fi
    
    if ! command -v "$ZOMBIENET_BIN" >/dev/null 2>&1; then
        echo "âŒ Error: Zombienet binary not found"
        echo "   Tried: $ZOMBIENET_BIN"
        echo "   Set ZOMBIENET_BINARY environment variable or ensure zombienet-* exists in parent directory"
        exit 1
    fi

    echo "   Setting up Polkadot runtime..."
    ROOT_DIR="{{ justfile_directory() }}/.."
    # Build the node binary (which will build the runtime as a dependency)
    cargo build --release -p polkadot-bulletin-chain
    POLKADOT_BULLETIN_BINARY_PATH="$ROOT_DIR/target/release/polkadot-bulletin-chain"

    cat <<EOF
    âš¡ Starting Bulletin chain with zombienet
        runtime   : {{ runtime }}
        test_dir  : {{ test_dir }}
        zombienet : $ZOMBIENET_BIN
        POLKADOT_BULLETIN_BINARY_PATH : $POLKADOT_BULLETIN_BINARY_PATH
    EOF
    cd "$ROOT_DIR"
    (yes y | POLKADOT_BULLETIN_BINARY_PATH="$POLKADOT_BULLETIN_BINARY_PATH" \
        $ZOMBIENET_BIN -p native spawn --dir {{ test_dir }} "$ROOT_DIR/zombienet/bulletin-polkadot-local.toml" > {{ test_dir }}/zombienet.log 2>&1) &
    cd -

    ZOMBIENET_PID=$!
    echo $ZOMBIENET_PID > {{ test_dir }}/zombienet.pid
    echo "   Zombienet PID: $ZOMBIENET_PID"
    echo "   Log: {{ test_dir }}/zombienet.log"
    # TODO: replace with better check for produced/finalized block 1 with timeout 60s
    echo "   Waiting for chain to start (60 seconds)..."
    sleep 60

# Start westend parachain with zombienet in background
# Parameters:
#   runtime - Runtime name (e.g., "bulletin-polkadot-parachain-runtime", "bulletin-westend-runtime"), taken from ../scripts/runtimes-matrix.json
bulletin-westend-parachain-zombienet-start test_dir runtime="bulletin-westend-runtime":
    #!/usr/bin/env bash
    set -e

    # Find zombienet binary (use env var if set, otherwise search)
    if [ -n "$ZOMBIENET_BINARY" ]; then
        ZOMBIENET_BIN="$ZOMBIENET_BINARY"
    else
        ZOMBIENET_BIN=$(ls ../zombienet-*-* 2>/dev/null | head -n 1)
    fi

    if ! command -v "$ZOMBIENET_BIN" >/dev/null 2>&1; then
        echo "âŒ Error: Zombienet binary not found"
        echo "   Tried: $ZOMBIENET_BIN"
        echo "   Set ZOMBIENET_BINARY environment variable or ensure zombienet-* exists in parent directory"
        exit 1
    fi

    # Run prerequisites setup first
    just setup-parachain-prerequisites

    # Set paths to binaries
    if [ -n "$SKIP_PARACHAIN_SETUP" ]; then
        # Expect in the PATH
        POLKADOT_BINARY_PATH=polkadot
        POLKADOT_PARACHAIN_BINARY_PATH=polkadot-omni-node
    else
        POLKADOT_BINARY_PATH=~/local_bulletin_testing/bin/polkadot
        POLKADOT_PARACHAIN_BINARY_PATH=~/local_bulletin_testing/bin/polkadot-omni-node
    fi

    # Verify binaries exist after setup
    if ! command -v "$POLKADOT_BINARY_PATH"; then
        echo "âŒ Error: Prerequisites setup completed but binaries still not found"
        echo "   Expected POLKADOT_BINARY_PATH: $POLKADOT_BINARY_PATH"
        exit 1
    fi
    if ! command -v "$POLKADOT_PARACHAIN_BINARY_PATH"; then
        echo "âŒ Error: Prerequisites setup completed but binaries still not found"
        echo "   Expected POLKADOT_PARACHAIN_BINARY_PATH: $POLKADOT_PARACHAIN_BINARY_PATH"
        exit 1
    fi

    # Create chain spec
    echo "   Creating Westend chain spec..."
    # Ensure binaries are in PATH and run from root directory
    ROOT_DIR="{{ justfile_directory() }}/.."
    cd "$ROOT_DIR"
    PATH="$HOME/local_bulletin_testing/bin:$PATH" ./scripts/create_bulletin_westend_spec.sh
    cd -

    # Run zombienet from root directory so relative paths in config work correctly
    cat <<EOF
    âš¡ Starting Bulletin chain with zombienet
        runtime   : {{ runtime }}
        test_dir  : {{ test_dir }}
        zombienet : $ZOMBIENET_BIN
        POLKADOT_BINARY_PATH : $POLKADOT_BINARY_PATH
        POLKADOT_PARACHAIN_BINARY_PATH : $POLKADOT_PARACHAIN_BINARY_PATH
    EOF
    cd "$ROOT_DIR"
    (yes y | POLKADOT_BINARY_PATH=$POLKADOT_BINARY_PATH \
        POLKADOT_PARACHAIN_BINARY_PATH=$POLKADOT_PARACHAIN_BINARY_PATH \
        $ZOMBIENET_BIN -p native spawn --dir {{ test_dir }} "$ROOT_DIR/zombienet/bulletin-westend-local.toml" > {{ test_dir }}/zombienet.log 2>&1) &
    cd -

    ZOMBIENET_PID=$!
    echo $ZOMBIENET_PID > {{ test_dir }}/zombienet.pid
    echo "   Zombienet PID: $ZOMBIENET_PID"
    echo "   Log: {{ test_dir }}/zombienet.log"
    # TODO: replace with better check for produced/finalized block 1 with timeout 180s
    echo "   Waiting for chain to start (180 seconds)..."
    sleep 180

# Check if Docker is available and running
_check-docker:
    #!/usr/bin/env bash
    if ! command -v docker &> /dev/null; then
        echo "âŒ Error: Docker is not installed."
        echo "   Please install Docker Desktop from: https://www.docker.com/products/docker-desktop"
        exit 1
    fi
    
    if ! docker ps &> /dev/null; then
        echo "âŒ Error: Docker is not running."
        echo "   Please start Docker Desktop and try again."
        echo "   On macOS: Open Docker Desktop from Applications"
        exit 1
    fi

# Start IPFS Docker container
ipfs-start test_dir: _check-docker
    #!/usr/bin/env bash
    set -e
    echo "ğŸ³ Starting IPFS Docker container..."

    # Use non-standard ports to avoid conflicts with other IPFS instances
    IPFS_SWARM_PORT=4011
    IPFS_API_PORT=5011
    IPFS_GATEWAY_PORT=8283

    # Pull latest kubo image if not present
    docker pull ipfs/kubo:latest

    # Remove old volume to start fresh (no cached peers)
    docker volume rm ipfs-data 2>/dev/null || true

    # Determine network mode based on OS
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS - use bridge with port mapping
        NETWORK_ARGS="-p ${IPFS_SWARM_PORT}:${IPFS_SWARM_PORT} -p ${IPFS_GATEWAY_PORT}:${IPFS_GATEWAY_PORT} -p ${IPFS_API_PORT}:${IPFS_API_PORT}"
    else
        # Linux (including CI) - use host networking so container can reach localhost services
        NETWORK_ARGS="--network host"
    fi

    # Start container - daemon will init and start
    docker run -d --name ipfs-node -v ipfs-data:/data/ipfs $NETWORK_ARGS ipfs/kubo:latest
    echo "   Container: ipfs-node (network: $NETWORK_ARGS)"
    echo "   Waiting for IPFS to initialize..."
    sleep 5

    # Configure IPFS for isolated mode while daemon is running (config changes take effect on restart)
    echo "   Configuring isolated mode..."
    docker exec ipfs-node ipfs bootstrap rm --all
    docker exec ipfs-node ipfs config --json Routing.Type '"none"'
    docker exec ipfs-node ipfs config --json Discovery.MDNS.Enabled false
    docker exec ipfs-node ipfs config --json Swarm.RelayClient.Enabled false
    docker exec ipfs-node ipfs config --json Swarm.RelayService.Enabled false

    # Configure custom ports to avoid conflicts with other IPFS instances
    echo "   Configuring custom ports (swarm: ${IPFS_SWARM_PORT}, api: ${IPFS_API_PORT}, gateway: ${IPFS_GATEWAY_PORT})..."
    docker exec ipfs-node ipfs config --json Addresses.Swarm "[\"/ip4/0.0.0.0/tcp/${IPFS_SWARM_PORT}\", \"/ip6/::/tcp/${IPFS_SWARM_PORT}\"]"
    docker exec ipfs-node ipfs config Addresses.API "/ip4/0.0.0.0/tcp/${IPFS_API_PORT}"
    docker exec ipfs-node ipfs config Addresses.Gateway "/ip4/0.0.0.0/tcp/${IPFS_GATEWAY_PORT}"

    # Restart container to apply config changes
    echo "   Restarting daemon with isolated config..."
    docker restart ipfs-node
    sleep 5

    docker exec ipfs-node ipfs --version

    # Bitswap logging
    docker logs -f ipfs-node > {{ test_dir }}/ipfs-node.log 2>&1 &
    docker exec ipfs-node ipfs log level bitswap debug
    docker exec ipfs-node ipfs log level bitswap/client debug

    # Store container name in PID directory for cleanup
    echo "ipfs-node" > {{ test_dir }}/ipfs-docker.container

# Connect to IPFS nodes using Docker
ipfs-connect runtime:
    #!/usr/bin/env bash
    set -e

    echo "ğŸ”— Connecting IPFS nodes (Docker, runtime: {{ runtime }})..."

    # Detect the correct host and protocol for Docker
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS - use dns4/host.docker.internal (bridge network)
        PROTOCOL="dns4"
        DOCKER_HOST="host.docker.internal"
    else
        # Linux - use ip4/127.0.0.1 (host network mode)
        PROTOCOL="ip4"
        DOCKER_HOST="127.0.0.1"
    fi

    echo "   Using Docker host: /$PROTOCOL/$DOCKER_HOST"

    # Different peer IDs and ports for different runtimes
    if [ "{{ runtime }}" = "bulletin-westend-runtime" ]; then
        # Westend parachain peer IDs (WebSocket ports: 10002, 12348)
        docker exec ipfs-node ipfs swarm connect /$PROTOCOL/$DOCKER_HOST/tcp/10002/ws/p2p/12D3KooWJKVVNYByvML4Pgx1GWAYryYo6exA68jQX9Mw3AJ6G5gQ || true
        docker exec ipfs-node ipfs swarm connect /$PROTOCOL/$DOCKER_HOST/tcp/12348/ws/p2p/12D3KooWJ8sqAYtMBX3z3jy2iM98XGLFVzVfUPtmgDzxXSPkVpZZ || true
    elif [ "{{ runtime }}" = "bulletin-polkadot-runtime" ]; then
        # Polkadot solo chain peer IDs (WebSocket ports: 10002, 12348)
        docker exec ipfs-node ipfs swarm connect /$PROTOCOL/$DOCKER_HOST/tcp/10002/ws/p2p/12D3KooWQCkBm1BYtkHpocxCwMgR8yjitEeHGx8spzcDLGt2gkBm || true
        docker exec ipfs-node ipfs swarm connect /$PROTOCOL/$DOCKER_HOST/tcp/12348/ws/p2p/12D3KooWRkZhiRhsqmrQ28rt73K7V3aCBpqKrLGSXmZ99PTcTZby || true
    else
        echo "ğŸ³ Unhandled runtime: {{ runtime }} specified!"
        exit 1
    fi

# Shutdown IPFS Docker container
ipfs-shutdown test_dir:
    #!/usr/bin/env bash
    
    echo "ğŸ›‘ Shutting down IPFS Docker container..."
    docker stop ipfs-node 2>/dev/null || echo "   âš  Container not running or already stopped"
    docker rm ipfs-node 2>/dev/null || echo "   âš  Container not found or already removed"
    docker volume rm ipfs-data 2>/dev/null || echo "   âš  Volume not found or already removed"
    
    # Clean up container file if it exists
    [ -f "{{ test_dir }}/ipfs-docker.container" ] && rm "{{ test_dir }}/ipfs-docker.container" && echo "   âœ“ Cleaned up container file" || true

# Start IPFS reconnect script in background (Docker mode)
ipfs-reconnect-start test_dir runtime:
    #!/usr/bin/env bash
    set -e
    echo "ğŸ”„ Starting IPFS reconnect script (Docker mode, runtime: {{ runtime }})..."
    
    # Use different reconnect script for westend
    ROOT_DIR="{{ justfile_directory() }}/.."
    cd "$ROOT_DIR"
    # TODO: improve this for multiple runtimes
    if [ "{{ runtime }}" = "bulletin-westend-runtime" ]; then
        ./scripts/ipfs-reconnect-westend.sh docker 10 > {{ test_dir }}/ipfs-reconnect.log 2>&1 &
    elif [ "{{ runtime }}" = "bulletin-polkadot-runtime" ]; then
        ./scripts/ipfs-reconnect-solo.sh docker 10 > {{ test_dir }}/ipfs-reconnect.log 2>&1 &
    else
        echo "ğŸ³ Unhandled runtime: {{ runtime }} specified!"
        exit 1
    fi
    cd -
    
    RECONNECT_PID=$!
    echo $RECONNECT_PID > {{ test_dir }}/ipfs-reconnect-docker.pid
    echo "   Reconnect PID: $RECONNECT_PID"
    echo "   Log: {{ test_dir }}/ipfs-reconnect.log"
    sleep 2

# Generate PAPI descriptors
# Generate PAPI descriptors from a running node
# Parameters:
#   ws_url - WebSocket URL of the node (default: ws://localhost:10000)
papi-generate ws_url="ws://localhost:10000": npm-install
    #!/usr/bin/env bash
    set -e

    echo "ğŸ”§ Generating PAPI descriptors from {{ ws_url }}..."
    cd typescript
    npx papi add -w "{{ ws_url }}" bulletin

# Setup all services using Docker for IPFS
# Parameters:
#   runtime - Runtime to build and run (e.g., "bulletin-polkadot-runtime", "bulletin-westend-runtime")
setup-services test_dir runtime: npm-install
    #!/usr/bin/env bash
    set -e

    # TODO: improve this for multiple runtimes
    if [ "{{ runtime }}" = "bulletin-westend-runtime" ]; then
        just bulletin-westend-parachain-zombienet-start "{{ test_dir }}" "{{ runtime }}"
    elif [ "{{ runtime }}" = "bulletin-polkadot-runtime" ]; then
        just bulletin-solo-zombienet-start "{{ test_dir }}" "{{ runtime }}"
    else
        echo "ğŸ³ Unhandled runtime: {{ runtime }} specified!"
        exit 1
    fi

    # Generate PAPI descriptors from running node.
    just papi-generate

    # Start IPFS
    echo "ğŸ”§ Tearing down Docker services if they are running..."
    just ipfs-shutdown "{{ test_dir }}"
    echo "ğŸ³ Setting up services with Docker IPFS (runtime: {{ runtime }})..."
    just ipfs-start "{{ test_dir }}"
    just ipfs-connect "{{ runtime }}"
    just ipfs-reconnect-start "{{ test_dir }}" "{{ runtime }}"

    echo "âœ… Services setup complete (Docker mode)"

# Stop all Docker services
teardown-services test_dir:
    #!/usr/bin/env bash

    # Stop all background processes
    just kill-pids "{{ test_dir }}"

    # Stop Docker container
    echo "ğŸ§¹ Stopping all Docker services..."
    just ipfs-shutdown "{{ test_dir }}"
    echo "âœ… Docker services stopped"

# Start all services for a runtime (use with run-test-* recipes)
# Usage: just start-services /tmp/my-test-dir bulletin-polkadot-runtime
start-services test_dir runtime:
    #!/usr/bin/env bash
    set -e
    mkdir -p "{{ test_dir }}"
    just setup-services "{{ test_dir }}" "{{ runtime }}"

# Stop all services
# Usage: just stop-services /tmp/my-test-dir
stop-services test_dir:
    #!/usr/bin/env bash
    echo "ğŸ“ Stopping services - test directory: {{ test_dir }}"
    just teardown-services "{{ test_dir }}"
    echo "âœ… Services stopped"

# Run TypeScript example (services must already be running via start-services)
# Parameters:
#   example - Example name (e.g., "authorize-and-store", "store-chunked-data")
#   test_dir - Test directory where services are running
#   runtime - Runtime name for smoldot chainspec path resolution
#   mode - Connection mode: "papi" (WebSocket RPC) or "smoldot" (light client)
#   ws_url - WebSocket URL (default: ws://localhost:10000, only used in papi mode)
#   seed - Account seed phrase or dev seed (default: //Alice, only used in papi mode)
#   http_ipfs_api - IPFS API URL (default: http://127.0.0.1:8283)
run-test-ts example test_dir runtime mode="papi" ws_url="ws://localhost:10000" seed="//Alice" http_ipfs_api="http://127.0.0.1:8283":
    #!/usr/bin/env bash
    set -e
    cd typescript

    if [ "{{ example }}" = "authorize-and-store" ]; then
        if [ "{{ mode }}" = "smoldot" ]; then
            echo "ğŸ§ª Running {{ example }} (mode: smoldot, runtime: {{ runtime }})..."
            SCRIPT_PATH="authorize-and-store/smoldot.js"
            # Run with chainspec paths for smoldot mode
            if [ "{{ runtime }}" = "bulletin-westend-runtime" ]; then
                RELAY_CHAINSPEC_PATH="{{ test_dir }}/bob/cfg/westend-local.json"
                PARACHAIN_CHAINSPEC_PATH="{{ test_dir }}/bulletin-westend-collator-2/cfg/westend-local-2487.json"
                node "$SCRIPT_PATH" "$RELAY_CHAINSPEC_PATH" "$PARACHAIN_CHAINSPEC_PATH" "{{ http_ipfs_api }}"
            else
                CHAINSPEC_PATH="{{ test_dir }}/bob/cfg/bulletin-polkadot-local.json"
                node "$SCRIPT_PATH" "$CHAINSPEC_PATH" "" "{{ http_ipfs_api }}"
            fi
        else
            echo "ğŸ§ª Running {{ example }} (mode: papi)..."
            node "authorize-and-store/papi.js" "{{ ws_url }}" "{{ seed }}" "{{ http_ipfs_api }}"
        fi
    else
        echo "ğŸ§ª Running {{ example }}..."
        node "{{ example }}/index.js" "{{ ws_url }}" "{{ seed }}" "{{ http_ipfs_api }}"
    fi

# Run Rust example (services must already be running via start-services)
# Parameters:
#   example - Example name (e.g., "authorize-and-store")
#   test_dir - Test directory where services are running
#   ws_url - WebSocket URL of the Bulletin Chain node (default: ws://localhost:10000)
#   seed - Seed phrase or dev seed (default: //Alice)
run-test-rust example test_dir ws_url="ws://localhost:10000" seed="//Alice":
    #!/usr/bin/env bash
    set -e
    echo "ğŸ¦€ Running Rust {{ example }}..."
    echo "   WS URL: {{ ws_url }}"
    echo "   Seed: {{ seed }}"

    # Fetch metadata from running node (required for subxt compilation)
    cd "rust/{{ example }}"
    echo "ğŸ“¥ Fetching metadata from {{ ws_url }}..."
    ./fetch_metadata.sh "{{ ws_url }}"

    # Touch source file to force rebuild with new metadata
    # This ensures cargo rebuilds even if only metadata changed
    touch src/main.rs
    cd ../..

    # Build the Rust binary
    ROOT_DIR="{{ justfile_directory() }}/.."
    EXAMPLE_NAME=$(echo "{{ example }}" | tr '-' '_')
    cargo build --release --manifest-path "rust/{{ example }}/Cargo.toml"

    # Run the example
    "./rust/{{ example }}/target/release/{{ example }}" --ws "{{ ws_url }}" --seed "{{ seed }}"

# Run all tests (services must already be running via start-services)
# This is a convenience recipe that runs all tests in sequence
# Parameters:
#   test_dir - Test directory where services are running
#   runtime - Runtime name for mode-specific tests (e.g., "bulletin-polkadot-runtime", "bulletin-westend-runtime")
run-all-tests test_dir runtime:
    #!/usr/bin/env bash
    set -e
    echo "ğŸ§ª Running all tests..."

    just run-test-ts authorize-and-store "{{ test_dir }}" "{{ runtime }}" "papi"
    just run-test-rust authorize-and-store "{{ test_dir }}"
    just run-test-ts authorize-and-store "{{ test_dir }}" "{{ runtime }}" "smoldot"
    just run-test-ts store-chunked-data "{{ test_dir }}" "{{ runtime }}"
    just run-test-ts store-big-data "{{ test_dir }}" "{{ runtime }}" "papi" "ws://localhost:10000" "//Alice" "http://127.0.0.1:5011"

    # TODO: TEMPORARILY DISABLED - authorize-preimage-and-store test failing with unsigned transactions
    #
    # Issue: The test's unsigned transactions are being rejected by the runtime with:
    #   InvalidTxError: { "type": "Invalid", "value": { "type": "Payment" } }
    #
    # Root Cause: When using PAPI's getBareTx() to create unsigned transactions, the runtime's
    # ValidateSigned transaction extension is rejecting them with a Payment validation error.
    # The transaction is successfully broadcast to the mempool but fails during validation.
    #
    # The pallet's ValidateUnsigned implementation looks correct and should handle unsigned
    # store() calls with preimage authorization. The issue appears to be in how the runtime's
    # transaction extension pipeline processes unsigned transactions - specifically the
    # ValidateSigned extension may be incorrectly applied before ValidateUnsigned runs.
    #
    # Potential Solutions:
    # 1. Runtime Fix: Ensure ValidateSigned extension properly skips unsigned transactions
    #    - Check that ValidateSigned::validate() returns early for unsigned origins
    #    - Verify transaction extension ordering in TxExtension tuple
    #
    # 2. PAPI Fix: Investigate if getBareTx() is creating proper unsigned extrinsics
    #    - Verify the extrinsic format matches runtime expectations
    #    - Check if signature/payment fields are being set to None/default properly
    #
    # 3. Test Alternative: Modify test to use signed transactions with preimage auth
    #    - The pallet supports signed transactions that prefer preimage authorization
    #    - This would test the same authorization flow without unsigned transaction complexity
    #
    # 4. Transaction Extension: Add SkipCheckIfFeeless or similar to bypass payment for authorized txs
    #    - Similar to how some parachains handle feeless operations
    #
    # References:
    # - Pallet ValidateUnsigned: pallets/transaction-storage/src/lib.rs:747-763
    # - ValidateSigned extension: runtimes/bulletin-polkadot/src/lib.rs:513-643
    # - Test file: examples/typescript/authorize-preimage-and-store/index.js
    #
    # just run-test-ts authorize-preimage-and-store "{{ test_dir }}" "{{ runtime }}"

    echo "âœ… All tests passed!"

# ============================================================================
# Standalone recipes (with full setup/teardown) - kept for local dev convenience
# ============================================================================

# Run authorize and store example with Docker IPFS
# Parameters:
#   mode - Connection mode: "papi" (WebSocket RPC node) or "smoldot" (light client)
#   runtime - Runtime name (e.g., "bulletin-polkadot-runtime", "bulletin-westend-runtime")
run-authorize-and-store runtime mode="papi": npm-install
    #!/usr/bin/env bash
    set -e

    echo "ğŸš€ Starting authorize and store workflow test (mode: {{ mode }}, runtime: {{ runtime }})..."

    TEST_DIR="$(just compute-test-dir)"
    just setup-services "$TEST_DIR" "{{ runtime }}"

    set +e
    just run-test-ts authorize-and-store "$TEST_DIR" "{{ runtime }}" "{{ mode }}"
    EXAMPLE_EXIT=$?

    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    if [ $EXAMPLE_EXIT -eq 0 ]; then
        echo "âœ… Example completed successfully!"
    else
        echo "âŒ Example failed with exit code $EXAMPLE_EXIT"
    fi

    just teardown-services "$TEST_DIR"
    exit $EXAMPLE_EXIT

# Run store chunked data example with Docker IPFS
# Parameters:
#   runtime - Runtime name (e.g., "bulletin-polkadot-runtime", "bulletin-westend-runtime")
#   ws_url - WebSocket URL (default: ws://localhost:10000)
#   seed - Account seed phrase or dev seed (default: //Alice)
#   http_ipfs_api - IPFS API URL (default: http://127.0.0.1:8283)
run-store-chunked-data runtime ws_url="ws://localhost:10000" seed="//Alice" http_ipfs_api="http://127.0.0.1:8283": npm-install
    #!/usr/bin/env bash
    set -e

    echo "ğŸš€ Starting store chunked data + DAG-PB workflow test (runtime: {{ runtime }})..."

    TEST_DIR="$(just compute-test-dir)"
    just setup-services "$TEST_DIR" "{{ runtime }}"

    set +e
    node store_chunked_data.js "{{ ws_url }}" "{{ seed }}" "{{ http_ipfs_api }}"
    EXAMPLE_EXIT=$?

    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    if [ $EXAMPLE_EXIT -eq 0 ]; then
        echo "âœ… Example completed successfully!"
    else
        echo "âŒ Example failed with exit code $EXAMPLE_EXIT"
    fi

    just teardown-services "$TEST_DIR"
    exit $EXAMPLE_EXIT

# Run store big data example.
# Parameters:
#   runtime - Runtime name (e.g., "bulletin-polkadot-runtime", "bulletin-westend-runtime")
#   ws_url - WebSocket URL (default: ws://localhost:10000)
#   seed - Account seed phrase or dev seed (default: //Alice)
#   http_ipfs_api - IPFS API URL (default: http://127.0.0.1:5011)
run-store-big-data runtime ws_url="ws://localhost:10000" seed="//Alice" http_ipfs_api="http://127.0.0.1:5011": npm-install
    #!/usr/bin/env bash
    set -e

    echo "ğŸš€ Starting store big data workflow test ..."

    TEST_DIR="$(just compute-test-dir)"
    just setup-services "$TEST_DIR" "{{ runtime }}"

    set +e
    node store_big_data.js "{{ ws_url }}" "{{ seed }}" "{{ http_ipfs_api }}"
    EXAMPLE_EXIT=$?

    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    if [ $EXAMPLE_EXIT -eq 0 ]; then
        echo "âœ… Example completed successfully!"
    else
        echo "âŒ Example failed with exit code $EXAMPLE_EXIT"
    fi

    just teardown-services "$TEST_DIR"
    exit $EXAMPLE_EXIT

# Run authorize preimage and store with PAPI example.
# Parameters:
#   runtime - Runtime name (e.g., "bulletin-polkadot-runtime", "bulletin-westend-runtime")
#   ws_url - WebSocket URL (default: ws://localhost:10000)
#   seed - Account seed phrase or dev seed (default: //Alice)
#   http_ipfs_api - IPFS API URL (default: http://127.0.0.1:8283)
run-authorize-preimage-and-store-papi runtime ws_url="ws://localhost:10000" seed="//Alice" http_ipfs_api="http://127.0.0.1:8283": npm-install
    #!/usr/bin/env bash
    set -e

    echo "ğŸš€ Starting authorize preimage and store with PAPI workflow test ..."

    TEST_DIR="$(just compute-test-dir)"
    just setup-services "$TEST_DIR" "{{ runtime }}"

    set +e
    node authorize_preimage_and_store_papi.js "{{ ws_url }}" "{{ seed }}" "{{ http_ipfs_api }}"
    EXAMPLE_EXIT=$?

    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    if [ $EXAMPLE_EXIT -eq 0 ]; then
        echo "âœ… Example completed successfully!"
    else
        echo "âŒ Example failed with exit code $EXAMPLE_EXIT"
    fi

    just teardown-services "$TEST_DIR"
    exit $EXAMPLE_EXIT

# ============================================================================
# Live network tests (external endpoints - Westend, Paseo, etc.)
# ============================================================================
#
# Run store-big-data test against live Bulletin chain deployments.
# These require pre-authorized accounts.
#
# Usage:
#   just run-live-tests-westend <seed>
#   just run-live-tests-westend <seed> http://127.0.0.1:8283 small

# Live network endpoints
WESTEND_RPC := "wss://westend-bulletin-rpc.polkadot.io"
PASEO_RPC := "wss://paseo-bulletin-rpc.polkadot.io"

# Run store-big-data test against a live endpoint
# Parameters:
#   ws_url - WebSocket URL of the Bulletin chain node
#   seed - Account seed phrase (must be pre-authorized on the network)
#   ipfs_gateway_url - IPFS Gateway URL (default: http://127.0.0.1:8283)
#   image_size - Image size preset: small, big32, big64, big96 (default: small)
_run-live-tests ws_url seed ipfs_gateway_url="http://127.0.0.1:8283" image_size="small": npm-install
    #!/usr/bin/env bash
    set -e
    echo "ğŸŒ Running live tests against: {{ ws_url }}"
    just papi-generate "{{ ws_url }}"
    node store_big_data.js "{{ ws_url }}" "{{ seed }}" "{{ ipfs_gateway_url }}" "{{ image_size }}" --skip-authorize --skip-ipfs-verify

# Run live tests against Westend Bulletin
run-live-tests-westend seed ipfs_gateway_url="http://127.0.0.1:8283" image_size="small":
    just _run-live-tests "{{ WESTEND_RPC }}" "{{ seed }}" "{{ ipfs_gateway_url }}" "{{ image_size }}"

# Run live tests against Paseo Bulletin
run-live-tests-paseo seed ipfs_gateway_url="http://127.0.0.1:8283" image_size="small":
    just _run-live-tests "{{ PASEO_RPC }}" "{{ seed }}" "{{ ipfs_gateway_url }}" "{{ image_size }}"
